To solve this problem, we need to do two main things:
1. Calculate all the lucky numbers.
2. Return the appropriate lucky numbers for each input.
The way to calculate all the lucky numbers is by segment tree, for each lucky number, remove all the numbers
which their location index is devidable by the lucky number.
why segment tree? we can't do that using a list or a vector it take so much runtime.
Tree's size will be 2*n,we can access each element in some index according to the sums in each node of the tree,
if some node contains the number k, that means it has k 1's in its subtree.
So the main operation of finding the lucky numbers is by taking each lucky number: 3, 7, ..., and turn off all the
bits in the tree where their location is devidable by the lucky number.


After calculating all the lucky numbers, we need to consider the input numbers.
We can notice that each odd input number cannot be a sum of two lucky numbers, as all lucky numbers are odd too.
After some experiments, I have noticed that each even number is a sum of two lucky numbers, and those two
numbers can be found by taking the half of the input number and checking pairs which are close to this half.


Time complexity:

Calculating all the lucky numbers - O(S * log(n)) where S is the number of lucky numbers in the range [1, 2000000]
Calculating the sums according to the input - O(INPUT_SIZE * T) where T is the difference between the input
number devided by two and one of the output numbers. T is not a constant and is differs for each input number,
but it's small enough to be considered as O(1).

Total - O(S * log(n)) - ~3 million operations






